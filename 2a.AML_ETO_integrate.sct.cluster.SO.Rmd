---
title: "AML-ETO SO - integrate, sct, cluster"
author: "TLusardi"
date: "11/05/2020"
output:
  html_document:
    df_print: paged
    toc: yes
  html_notebook:
    toc: yes
    toc_float: yes
params:
  local: TRUE
---

Integrate objects   
* Use all features so can pass object to P3

Assign Cell cycle scores
* Can compare assignment to individual run assignments

Run SCTransform on individual objects   
* regress - Cell cycle
  + noregress
  + regress.CC - regress on cell cycle - probably not the best option as it removes any cell cycle information that may be important for differentiating cells
  + regress.diff - regress on the difference in cell cycle values; per Seurat notations, it preserves cell cycle information relevant to development
* regress - other features
  + nCounts_RNA + percent.mt
  
Cluster & Plot!

Save each object to a separate file

importDate - select the creation date for the desired object
  
### Set up libraries and directories

```{r "setup_libs", include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(data.table)
library(ggplot2)
library(knitr)
library(networkD3)
library(patchwork)
library(dplyr)

runs2process = c("dmso", "ava", "ory", "combo")
baseline = "dmso"
importDate <- "2021-01-05"
```

```{r "setup_vars", include=FALSE}
directory = list(raw = "/Users/lusardi/Documents/CEDAR/Projects/3.ASXL_mutant/1.AML_ETO/analysis/data/raw",
                 rda = "/Users/lusardi/Documents/CEDAR/Projects/3.ASXL_mutant/1.AML_ETO/analysis/data/rda")

expts.ls <- readRDS(sprintf("%s/aml_eto.preprocSO.nofilt.%s.rds", directory$rda, importDate))
```

### Plot Counts Comparisons

```{r, echo=FALSE}
plotSet = list(dmso = list(col = "#e41a1c", lty = 1),
               ava = list(col = "#377eb8", lty = 1),
               ory = list(col = "#4daf4a", lty = 1),
               combo = list(col = "#adaf4a", lty = 1))
runs <- names(expts.ls)

plotFeatures <- c("nCount_RNA", "nFeature_RNA")
for (myfeature in plotFeatures) {
  # Set up Density Plot
  maxDens <- 0
  maxCts <- 0
  for (myrun in names(expts.ls)) {
    mydens <- density(expts.ls[[myrun]]@meta.data[[myfeature]])
    maxDens <- max(maxDens, mydens$y)
    maxPct <- 1
    maxCts <- max(maxCts, expts.ls[[myrun]]@meta.data[[myfeature]])
  }

  # Create a plot pane
  plot(NULL, xlim=c(0, maxCts), ylim = c(0, maxDens), 
       xlab = sprintf("%s", myfeature),
       ylab = "Density", las = 1,
       main = sprintf("Distribution of %s per Cell by Experiment", myfeature))
  abline(h = 0, col = "grey80")

  # Add a legend
  legend(x="topright", legend = runs, lwd = 2,
         col = unlist(plotSet)[paste(runs, "col", sep = ".")],
         lty = as.numeric(unlist(plotSet)[paste(runs, "lty", sep = ".")]))

  # Plot each density line
  for (myrun in names(expts.ls)) {
    lines(density(expts.ls[[myrun]]@meta.data[[myfeature]]), col = plotSet[[myrun]]$col,
          lwd = 2)
  }
}
```

### Normalize & Scale
Use SCTransform with regression options noted
Calculate pca and umap 

Preserve all features for Precepts compatibility

```{r, "runSCT", warning=FALSE, echo=FALSE}
regressions <- list(noregression = "NULL",
                    regress.CC = c("S.Score", "G2M.Score"),
                    regress.Diff = c("CC.Difference"))    
regression2use <- "regress.Diff"

for (myregress in regression2use) {
  for (myrun in names(expts.ls)) {
    myso <- expts.ls[[myrun]]
    if (myregress == "noregression") {
      myassay <- "SCT"
      myso <- SCTransform(myso, verbose = FALSE, new.assay.name = myassay,
                            variable.features.n = nrow(myso@assays$RNA@counts))
    } else {
      myassay <- gsub("regress", "SCT", myregress)
      myso <- SCTransform(myso, verbose = FALSE, new.assay.name = myassay,
                            vars.to.regress = regressions[[myregress]],
                            variable.features.n = nrow(myso@assays$RNA@counts))
    }
    
    # Calculate pca
    mypca <- gsub("SCT", "pca", myassay)
    mypcakey <- paste(gsub("/.", "", mypca), "_", sep = "")
    myso <- RunPCA(myso, verbose = FALSE, assay = myassay,
                     reduction.name = mypca, reduction.key = mypcakey)
      
    # Create umap
    myumap <- gsub("pca", "umap", mypca)
    myumapkey <- paste(gsub("/.", "", myumap), "_", sep = "")
    myso <- RunUMAP(myso, dims = 1:30, assay = myassay,
                      reduction = mypca, reduction.name = myumap, reduction.key = myumapkey)
    
    expts.ls[[myrun]] <- myso
  } 
}
```

### Optionally Plot Missing Features
Note that features present in <= 4 cells do not make it through SCTransform

```{r, "plotmissingfeat",echo=FALSE}
if (TRUE) {
  for (myrun in names(expts.ls)) {
    myso <- expts.ls[[myrun]]
    lostFeat <- rownames(myso@assays$RNA@counts)[!(rownames(myso@assays$RNA@counts) %in% rownames(myso@assays$SCT.Diff@counts))]
    counts.per.feat <- apply(myso@assays$RNA@counts, 1, sum)
    cells.per.feat <- Matrix::rowSums(myso@assays$RNA@counts > 0)
    
    # Plot counts and cells 
    plot(x = log2(counts.per.feat), y = log2(cells.per.feat), pch = 20, cex = 0.5)
    points(x = log2(counts.per.feat[lostFeat]), y = log2(cells.per.feat[lostFeat]), pch = 20, cex = 0.5, col = "red")
  }
}
```

### Cluster the individual runs
Note: Ran individual PCA/UMAP on a subset of genes in 1a.    
Run here on all genes? Not sure that this will substantially change anything.

```{r, "iCluster", echo=FALSE, warning=FALSE, message=FALSE}
for (myrun in names(expts.ls)) {
  myso <- expts.ls[[myrun]]
  
  for (myregress in regression2use) {
    myassay <- gsub("regress", "SCT", myregress)
    mypca <- gsub("regress", "pca.SCT", myregress)
    mypca_key <- gsub("regress", "pcaSCT_", myregress)
    myfeatures <- rownames(myso@assays[[myassay]])
    myumap <- gsub("pca", "umap", mypca)
    
    # Perform PCA on all features (note that non-variable features will be dropped)
    myso <- RunPCA(myso, assay = myassay, features = myfeatures,
                   reduction.name = mypca, reduction.key = mypca_key)
    
    myplot <- ElbowPlot(myso, reduction = mypca, ndims = 50)
    plot(myplot + plot_annotation(title = myrun, subtitle = myregress))
    DimHeatmap(myso, reduction = mypca, dims = 1:15, cells = 500, balanced = TRUE)
  
    myso <- FindNeighbors(myso, dims = 1:50, assay = myassay, reduction = mypca)
    mygraph <- paste(myassay, "snn", sep = "_")
    myso <- FindClusters(myso, graph.name = mygraph, resolution = 0.8)
    
    # Create UMAP
    myso <- RunUMAP(myso, reduction = mypca, dims = 1:50,reduction.name = myumap)
    myplot <- DimPlot(myso, reduction = myumap)
    plot(myplot + plot_annotation(title = myrun, subtitle = myregress))
  }
  expts.ls[[myrun]] <- myso
}
```

### Preliminary Cluster ID

```{r, "prelimClusterID", echo=FALSE}
markers <- list(early = c("SOX4"),
                mid = c("CEBPD"),
                late = c("CD14"))

for (myrun in runs2process) {
  myso <- expts.ls[[myrun]]
  
  for (mymarkers in names(markers)) {
    myplot <- FeaturePlot(myso, features = markers[[mymarkers]], label = TRUE, label.size = 5)
    plot(myplot + plot_annotation(title = myrun, subtitle = mymarkers))
  }
}

# Assign labels to DMSO
# Cluster Labels
Labels.ls <- list(dmso = c(SCT.Diff_0 = "early_1", SCT.Diff_1 = "late_2", SCT.Diff_2 = "mid_1",
                           SCT.Diff_3 = "lone_2", SCT.Diff_4 = "lone_3", SCT.Diff_5 = "late_1",
                           SCT.Diff_6 = "lone_1", SCT.Diff_7 = "lone_4"),
                  ava = c(SCT.Diff_0 = "late_2", SCT.Diff_1 = "early_1", SCT.Diff_2 = "mid_1",
                          SCT.Diff_3 = "early_2", SCT.Diff_4 = "lone_2", SCT.Diff_5 = "late_1",
                          SCT.Diff_6 = "lone_5", SCT.Diff_7 = "lone_1", SCT.Diff_8 = "lone_3",
                          SCT.Diff_9 = "lone_4"),
                  ory = c(SCT.Diff_0 = "late_1", SCT.Diff_1 = "early_1", SCT.Diff_2 = "early_2",
                          SCT.Diff_3 = "mid_1", SCT.Diff_4 = "mid_2", SCT.Diff_5 = "late_2",
                          SCT.Diff_6 = "lone_1", SCT.Diff_7 = "lone_3", SCT.Diff_8 = "lone_2",
                          SCT.Diff_9 = "lone_4", SCT.Diff_10 = "lone_5"),
                  combo = c(SCT.Diff_0 = "early_1", SCT.Diff_1 = "late_2", SCT.Diff_2 = "mid_1",
                            SCT.Diff_3 = "late_1", SCT.Diff_4 = "early_2", SCT.Diff_5 = "lone_1",
                            SCT.Diff_6 = "lone_2", SCT.Diff_7 = "lone_3", SCT.Diff_8 = "lone_4"))
label_order <- c("early_1", "early_2", "mid_1", "mid_2", "late_1", "late_2",
                 "lone_1", "lone_2", "lone_3", "lone_4", "lone_5")

# Rename Clusters 
# This could be more elegant...  I'm making lots of assumptions
colors <- c('#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928')
names(colors) <- label_order

for (myregress in regression2use) {
  for (myrun in runs2process) {
    myso <- expts.ls[[myrun]]
    mynorm <- gsub("regress", "SCT", myregress)
    
    # Create a named column
    myIdxname <- paste(mynorm, "clusterIdx", sep = "_")
    myso@meta.data[[myIdxname]] <- paste(mynorm, myso@meta.data$SCT.Diff_snn_res.0.8, sep = "_")
    
    # Create a labeled column (make it a factor for ease of reading)
    myIDname <- paste(mynorm, "clusterID", sep = "_")
    myso@meta.data[[myIDname]] <- factor(Labels.ls[[myrun]][myso@meta.data[[myIdxname]]], 
                                         levels = label_order, ordered = TRUE)
    
    plotcolors <- colors[unique(levels(myso@meta.data[[myIDname]]))]
    myplot <- DimPlot(myso, reduction = myumap, group.by = myIDname, cols = plotcolors)
    plot(myplot + plot_annotation(title = myrun, subtitle = mynorm))
    
    expts.ls[[myrun]] <- myso
  }
}
```

### Integrate the objects
Preserve as many features as possible in the integrated object

```{r, "integrate", echo=FALSE}
# Needed to avoid error in getGlobalsandPackages 
options(future.globals.maxSize= 3530*1024^2)

# Count the number of unique features per experiment
allFeatures <- NULL
for (myrun in names(expts.ls)) {
  allFeatures <- unique(c(allFeatures, rownames(expts.ls[[myrun]])))
}

expts.integrated.ls <- list()
for (myregress in regression2use) {
  # Select most variable features for integration
  myassay <- gsub("regress", "SCT", myregress)
  myfeatures <- SelectIntegrationFeatures(object.list = expts.ls, nfeatures = length(allFeatures),
                                          fvf.nfeatures = allFeatures, assay = rep(myassay, 4))
  
  # Calculate Pearson Residuals
  myiso <- PrepSCTIntegration(object.list = expts.ls, anchor.features = myfeatures,
                              verbose = FALSE, assay = rep(myassay, 4))
  
  # Identify integration anchors
  ref <- which(names(expts.ls) == baseline)
  my.anchors <- FindIntegrationAnchors(object.list = myiso, normalization.method = "SCT",
                                       assay = rep(myassay, 4),
                                       reference = ref, scale = FALSE,
                                       anchor.features = myfeatures, verbose = TRUE)
  
  # Integrate selected data
  integratedName <- paste("Integrated", myassay, sep = ".")
  myintegrated <- IntegrateData(anchorset = my.anchors, normalization.method = "SCT",
                                verbose = FALSE, new.assay.name = integratedName)
  
  expts.integrated.ls[[myregress]] <- myintegrated
}
```

### Optionally Plot Missing Features
Lose ~2500 features (of 16990) during integration

* Features must be present in all runs to be included in the integrated object
* Inclusion in the integrated object does not mean that the feature is widely or well represented
* Included and Missing summary counts are written to a csv `amleto_integratedFeatures_present/missing.csv`
* Summary table - dmso.ava.ory.combo:  1 present, 0 absent. 1.0.0.0 is only present in DMSO. 0.1.1.1 is present in all but dmso.

```{r, "plotmissingintegrated",echo=FALSE, results='asis'}
if (TRUE) {
  for (myregress in names(expts.integrated.ls)) {
    myiso <- expts.integrated.ls[[myregress]]
    lostFeat <- rownames(myiso@assays$SCT.Diff@counts)[!(rownames(myiso@assays$SCT.Diff@counts) %in% 
                                                           rownames(myiso@assays$Integrated.SCT.Diff@data))]
    
    # Collect information for lost and included features
    featureSummary.ls <- list(missing = data.table(featureID = lostFeat),
                              present = data.table(featureID = rownames(myiso)))
    
    featureLong.ls <- list()
    
    for (myfeat in names(featureSummary.ls)) {
      mydt <- featureSummary.ls[[myfeat]]
      
      # Collect the data from the SCT assay
      sct.cts.pf <- Matrix::rowSums(myiso@assays$SCT.Diff@counts)
      sct.cells.pf <- Matrix::rowSums(myiso@assays$SCT.Diff@counts > 0)
      
      # Summary data for the integrated object
      mydt[, sct.all.cts_pf := sct.cts.pf[featureID]]
      mydt[, sct.all.cells_pf := sct.cells.pf[featureID]]
    
      # Select missing features by cluster - any overrepresentation of a group?
      for (myrun in runs2process) {
        Idents(myiso) <- "SCT.Diff_clusterID"
        DefaultAssay(myiso) <- "SCT.Diff"
        mysubset <- subset(myiso[mydt$featureID,], subset = orig.ident == myrun)
      
        ss.sct.cts.pf <- Matrix::rowSums(mysubset@assays$SCT.Diff@counts)
        ss.sct.cells.pf <- Matrix::rowSums(mysubset@assays$SCT.Diff@counts > 0)
      
        myctsCol <- sprintf("sct.%s.cts_pf", myrun)
        mycellsCol <- sprintf("sct.%s.cells_pf", myrun)
           
        mydt[, (myctsCol) := ss.sct.cts.pf[featureID]]
        mydt[, (mycellsCol) := ss.sct.cells.pf[featureID]]
      }
      
      # Summarize which runs a gene is detected in
      mydt[, summaryPresent := sprintf("%i.%i.%i.%i",
                                       ifelse(sct.dmso.cells_pf > 0, 1,0),
                                       ifelse(sct.ava.cells_pf > 0, 1,0),
                                       ifelse(sct.ory.cells_pf > 0, 1,0),
                                       ifelse(sct.combo.cells_pf > 0, 1,0))]
    
      # Boxplot
      ctsCols <- colnames(mydt)[grepl("cts.pf", colnames(mydt))]
      cellsCols <- colnames(mydt)[grepl("cells.pf", colnames(mydt))]
    
      # Melt counts/cells
      mycts.dt <- melt(mydt[, mget(c("featureID", ctsCols))], id.vars = "featureID", variable.name = "run", value.name = "cts.pf")
      mycts.dt[, run := gsub(".cts.pf", "", run)]
      mycells.dt <- melt(mydt[, mget(c("featureID", cellsCols))], id.vars = "featureID", variable.name = "run", value.name = "cells.pf")
      mycells.dt[, run := gsub(".cells.pf", "", run)]
    
      counts.dt <- merge(x = mycts.dt, y = mycells.dt, by = c("featureID", "run"))
      counts.dt[,  ':=' (run = factor(run, levels = c("sct.all", "sct.dmso", "sct.ava", "sct.ory", "sct.combo")),
                         log2.cts = log2(cts.pf),
                         log2.cells = log2(cells.pf))]
    
      # Boxplot summary
      boxplot(log2.cts ~ run, data = counts.dt, las = 1, ylab = "log2(Counts per Feature)", xlab = "",
              main = sprintf("Summary counts per feature, %s features in integrated object", myfeat))
      stripchart(log2.cts ~ run, data = counts.dt, method = "jitter", jitter = .25, vertical = TRUE, add = TRUE, pch = 20, cex = 0.4)
      
      # Summary by pattern
      print(kable(mydt[, .N, by = summaryPresent][order(summaryPresent)],
                  caption = sprintf("Summary distribution of features %s in integrated object", myfeat)))
      
      # Save the summary data
      myfilename <- sprintf("amleto_integratedFeatures_%s.csv", myfeat)
      fwrite(mydt, file = paste(directory$rda, myfilename, sep = "/"))
      
      featureLong.ls[[myfeat]] <- counts.dt
      featureSummary.ls[[myfeat]] <- mydt
    }
  }
}
```

### Plot UMAP and PCA

```{r, echo=FALSE}
for (myfilt in names(expts.ls)) {
  for (myrun in names(expts.ls[[myfilt]])) {
    for (myregress in names(regressions)) {
      myassay <- ifelse(myregress == "noregression", "SCT", gsub("regress", "SCT", myregress))
      mypca <- gsub("SCT", "pca", myassay)
      plot(DimPlot(expts.ls[[myfilt]][[myrun]], reduction = mypca)  + labs(title = sprintf("%s: %s", myrun, myregress)))
    
      myumap <- gsub("SCT", "umap", myassay)
      plot(DimPlot(expts.ls[[myfilt]][[myrun]], reduction = myumap)  + labs(title = sprintf("%s: %s", myrun, myregress)))
    }
  }
}
```

### Save the data

```{r, echo=FALSE}
# Save the file
for (myfilt in names(expts.ls)) {
  file2save <- sprintf("aml_eto.regressSO.%s.%s.rds", myfilt, Sys.Date())
  print(sprintf("%s objects:  Saving scaled/normalized/regressed data in individual objects in %s", myfilt, file2save))
  saveRDS(expts.ls[[myfilt]], file = paste(directory$rda, file2save, sep = "/"))
}
```

```{r, echo=FALSE}
sessionInfo()
```
